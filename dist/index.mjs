var m=Object.defineProperty;var a=(r,t)=>m(r,"name",{value:t,configurable:!0});import s from"fs/promises";import c from"path";import w from"fs";import g from"os";typeof Symbol.asyncDispose!="symbol"&&Object.defineProperty(Symbol,"asyncDispose",{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for("asyncDispose")});class b{static{a(this,"FsFixture")}path;constructor(t){this.path=t}getPath(...t){return c.join(this.path,...t)}exists(t=""){return s.access(this.getPath(t)).then(()=>!0,()=>!1)}rm(t=""){return s.rm(this.getPath(t),{recursive:!0,force:!0})}writeFile(t,i){return s.writeFile(this.getPath(t),i)}writeJson(t,i){return this.writeFile(t,JSON.stringify(i,null,2))}readFile(t,i){return s.readFile(this.getPath(t),i)}async[Symbol.asyncDispose](){await this.rm()}}const P=w.realpathSync(g.tmpdir()),d=`fs-fixture-${Date.now()}`;let u=0;const F=a(()=>(u+=1,u),"getId");class l{static{a(this,"Symlink")}target;type;path;constructor(t,i){this.target=t,this.type=i}}const f=a((r,t,i)=>{const e=[];for(const o in r){if(!Object.hasOwn(r,o))continue;const p=c.join(t,o);let n=r[o];if(typeof n=="function"){const y=Object.assign(Object.create(i),{filePath:p}),h=n(y);if(h instanceof l){h.path=p,e.push(h);continue}else n=h}typeof n=="string"?e.push({path:p,content:n}):e.push(...f(n,p,i))}return e},"flattenFileTree"),j=a(async r=>{const t=c.join(P,`${d}-${F()}/`);if(await s.mkdir(t,{recursive:!0}),r){if(typeof r=="string")await s.cp(r,t,{recursive:!0});else if(typeof r=="object"){const i={fixturePath:t,getPath:a((...e)=>c.join(t,...e),"getPath"),symlink:a((e,o)=>new l(e,o),"symlink")};await Promise.all(f(r,t,i).map(async e=>{await s.mkdir(c.dirname(e.path),{recursive:!0}),e instanceof l?await s.symlink(e.target,e.path,e.type):await s.writeFile(e.path,e.content)}))}}return new b(t)},"createFixture");export{j as createFixture};
